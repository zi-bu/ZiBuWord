首先它是一个集合 有一个遍历器

没有四维维的键值对，所以需要自己搞这种模式
比如这样的一个向量
$$
\begin{bmatrix}
\text{单词} \\
\text{词性} \\
\text{释意} \\
\text{固定搭配} \\
\text{例句}
\end{bmatrix}
$$


$$
\begin{bmatrix}
\text{单词1} & \text{单词2} & \text{单词3} & \dots \\
\text{词性} & 2 & 3 & \dots \\
\text{释意} & 2 & 3 & \dots \\
\text{固定搭配} & 2 & 3 & \dots \\
\text{例句} & 2 & 3 & \dots \\
\end{bmatrix}
$$

所以应该是 集合对象[索引1 表示具体某个单词对象][索引2 表示具体的某一个单词属性]
0为单词 1为词性 2为释意 3为常见短语搭配
索引1为列号 索引2为行号
这个东西得是动态的 所以最先想到的一个模型就是列表
列表的序号可以视作是列号
而我们可以定义一个单词类的字段
赋予他们下标访问的语法

于是我们设计一个List
```C#
List<IWord> WordList = new List<IWord> {Word1,Word2,Word3}
//我们是否能使用一个索引器 WordList[0][1]来使用呢
//这样以用来简化下标或者是 get访问的复用 同时避开名字的污染？
```
至于接口实现的Word类，就交给子布了
或许构造函数你可以设想能否让他直接读取表的某一行或者某一列 来直接实现对象字段的初始化呢？
只是一个设想

这是我对接口的设计
```C#
public interface IWord  
{  
    //作为一个单词对象应被实现的字段包含以下  
    string word { get; } //单词  
    string pos { get; } //Part of Speech词性  
    string translation { get; } //释意  
    string phrase { get; } //短语  
    string example { get; } //例句  
  
    //定义一个单词的索引器  
    string this[int index] { get; } 
    //希望单词能运用下标访问的语法 就是从0到4 一一对应返回上述的内容  
}
```
这样在BLL层则可以利用一个列表List来存放单词变量 使用WordList[0][0]来get对应单词对象的对应字段

和鼠标的讨论：
细分了BLL层和DAL层实际应做的事项
比喻成一场战役，DAL层作为后勤部，会直接对数据库进行四大步---增删查改的操作
所以，他们就是直接负责将子弹装进了弹匣，
而BLL层直接使用它们提供好的后勤配件，装配自己的武器，因为是直接面向用户的交互。
这一部分可以利用面向对象的封装性，比起将表格拆碎，碾碎再在BLL组装，那当然是要在最底层的DAL层直接实现封装
在BLL层直接调取
BLL层更像是将已然完成的模块根据逻辑摆盘，而DAL层提供蔬菜沙拉的材料。
通过设计，把面向对象的思维体现出来 这就是封装和继承功能的优势

学艺不精，仅提供一个设想
